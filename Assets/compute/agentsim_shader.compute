#pragma kernel CSMain
#pragma kernel ImageProcess

RWStructuredBuffer<float4> AgentData;
RWTexture2D<float4> Result;

float _dt;

int _width;
int _height;
float _time;
float _agentRadius;


float2 random2(float2 st){
    st = float2( dot(st,float2(127.1,311.7)),
              dot(st,float2(269.5,183.3)) );
    return -1.0 + 2.0*frac(sin(st)*43758.5453123);
}


float noise(float2 st) { // gradient noise
    float2 i = floor(st);
    float2 f = frac(st);

    float2 u = f*f*(3.0-2.0*f);

    return lerp( lerp( dot( random2(i + float2(0.0,0.0) ), f - float2(0.0,0.0) ),
                     dot( random2(i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                lerp( dot( random2(i + float2(0.0,1.0) ), f - float2(0.0,1.0) ),
                     dot( random2(i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
}

float2 sense(float2 pos, float2 vel)
{   

    // sample 3x3 pixels around the agent
    int2 pixelPos = int2(pos.x, pos.y);
    float2 newDir = float2(0, 0);
    int counter = 0;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            float2 currentPos = float2(pixelPos.x + i, pixelPos.y + j);
            float2 dir = normalize(currentPos - pos);

            if (dot(vel,dir) > 0)
            {
                if (Result[currentPos].r > 0.5)
                {
                    newDir += dir;
                    counter++;
                }
            }
        }
    }

    if (counter > 0)
    {
        newDir /= counter;
        return normalize(newDir);
    }
    return vel;
}

void bounceAgents(inout float2 pos,inout  float2 vel)
{

    if (pos.x <= 0 || pos.x >= _width)
    {
        vel.x = -vel.x;
        pos.x = clamp(pos.x, 0, _width);
    }

    if (pos.y <= 0 || pos.y >= _height)
    {
        vel.y = -vel.y;
        pos.y = clamp(pos.y, 0, _height);
    }
}

// agent update loop
[numthreads(512,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 pos = AgentData[id.x].xy;
    float2 vel = AgentData[id.x].zw;

    // Define the radius for trail detection
    int radius = 4;
    float2 alignmentDirection = float2(0, 0);
    float2 separationDirection = float2(0, 0);
    float trailWeight = 0;

    // // Check nearby pixels within the specified radius for trails
    // for (int i = -radius; i <= radius; i++)
    // {
    //     for (int j = -radius; j <= radius; j++)
    //     {
    //         int2 neighborPos = int2(pos.x + i, pos.y + j);
    //         if (neighborPos.x >= 0 && neighborPos.x < _width && neighborPos.y >= 0 && neighborPos.y < _height)
    //         {
    //             // If a trail is detected at neighborPos
    //             float4 trailValue = Result[neighborPos];
    //             if (trailValue.r > 0.5) // Assuming red channel indicates a trail
    //             {
    //                 alignmentDirection += float2(i, j);
    //                 trailWeight += 1;
    //             }
    //         }
    //     }
    // }

    float2 seed1 = pos/200.0+ _time*0.1;
    float2 seed2 = pos/200.0- _time*0.1;

    float2 rand1 = float2(noise(seed1),noise(seed1+1732.34));
    float2 rand2 = float2(noise(seed2),noise(seed2+1732.34));

    float2 randPos = normalize(rand1+rand2);

    float2 randi = normalize(float2(noise(id.x*1240.0),noise(id.y*12320.0+1732.34)));

    // vel = sense(pos, vel);

    vel = normalize(vel+randPos*0.1+randi*0.05*sin(_time+randi.x*100.0));

    // if (trailWeight > 0)
    // {
    //     vel = normalize(vel+alignmentDirection*0.001+rand2);
    // }

    // Move and bounce agent
   
    
    bounceAgents(pos, vel);

    pos += vel *_dt*0.05;

    // Update agent data
    AgentData[id.x] = float4(pos, vel);

    // Draw the agent at its position
    int2 pixelPos = int2(pos.x, pos.y);
    if (pixelPos.x >= 0 && pixelPos.x < _width && pixelPos.y >= 0 && pixelPos.y < _height)
    {
        Result[pixelPos] = float4(1, 0, 0, 1); // Set the pixel color to red for the agent
    }
}


[numthreads(8,8,1)]
void ImageProcess (uint3 id : SV_DispatchThreadID)
{

    float4 color = Result[id.xy];

    float fadeFactor = 0.002;
    
    // blur the color by averaging the color of the neighboring pixels
    float4 sum = float4(0, 0, 0, 0);
    int count = 0;
    int range = 1;
    for (int i = -range; i <= range; i++)
    {
        for (int j = -range; j <= range; j++)
        {
            int2 neighborPos = int2(id.xy.x + i, id.xy.y + j);
            if (neighborPos.x >= 0 && neighborPos.x < _width && neighborPos.y >= 0 && neighborPos.y < _height)
            {
                sum += Result[neighborPos];
                count++;
            }
        }
    }
    color = sum / count;

    // Write the faded color back to the result
    Result[id.xy] = color-fadeFactor;
}
