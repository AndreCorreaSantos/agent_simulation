#pragma kernel CSMain
#pragma kernel ImageProcess

RWStructuredBuffer<float4> AgentData;
RWTexture2D<float4> Result;

float _dt;

int _width;
int _height;
float _time;
float _agentRadius;
float _threshold = 0.9;


float2 random2(float2 st){
    st = float2( dot(st,float2(127.1,311.7)),
              dot(st,float2(269.5,183.3)) );
    return -1.0 + 2.0*frac(sin(st)*43758.5453123);
}


float noise(float2 st) { // gradient noise
    float2 i = floor(st);
    float2 f = frac(st);

    float2 u = f*f*(3.0-2.0*f);

    return lerp( lerp( dot( random2(i + float2(0.0,0.0) ), f - float2(0.0,0.0) ),
                     dot( random2(i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                lerp( dot( random2(i + float2(0.0,1.0) ), f - float2(0.0,1.0) ),
                     dot( random2(i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
}

float2 Sense(float2 pos, float2 vel)
{
    int2 pixelPos = int2(pos.x, pos.y);
    float2 newDir = float2(0, 0);
    int counter = 0;

    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            float2 currentPos = float2(pixelPos.x + 3.0*i, pixelPos.y + 3.0*j);
            float2 dir = normalize(currentPos - pos);
            
            float dotp = dot(vel, dir);
            if (dotp > 0)
            {
                if (Result[int2(currentPos)].r > 0.5)
                {
                    newDir += dir;
                    counter++;
                }
            }
        }
    }

    if (counter > 0)
    {
        newDir /= counter;
        float lengthNewDir = length(newDir);
        // Blend new direction with existing velocity
        vel = normalize(lerp(vel, normalize(newDir), 0.5));
    }

    return vel;
}

void bounceAgents(inout float2 pos,inout  float2 vel)
{

    if (pos.x <= 0 || pos.x >= _width)
    {
        vel.x = -vel.x;
        pos.x = clamp(pos.x, 0, _width);
    }

    if (pos.y <= 0 || pos.y >= _height)
    {
        vel.y = -vel.y;
        pos.y = clamp(pos.y, 0, _height);
    }
}

// agent update loop
[numthreads(512,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 pos = AgentData[id.x].xy;
    float2 vel = AgentData[id.x].zw;


    // float2 seed1 = pos/200.0+ _time*0.1;
    // float2 seed2 = pos/200.0- _time*0.1;
    // float2 rand1 = float2(noise(seed1),noise(seed1+1732.34));
    // float2 rand2 = float2(noise(seed2),noise(seed2+1732.34));
    // float2 randPos = normalize(rand1+rand2);
    // float2 randi = normalize(float2(noise(id.x*1240.0),noise(id.y*12320.0+1732.34)));

    

    vel = Sense(pos, vel);

    // Move and bounce agent
   
    
    bounceAgents(pos, vel);

    pos += vel *_dt*0.1;

    // Update agent data
    AgentData[id.x] = float4(pos, vel);

    // Draw the agent at its position
    int2 pixelPos = int2(pos.x, pos.y);
    if (pixelPos.x >= 0 && pixelPos.x < _width && pixelPos.y >= 0 && pixelPos.y < _height)
    {
        Result[pixelPos] = float4(1, 0, 0, 1); // Set the pixel color to red for the agent
    }
}


[numthreads(8,8,1)]
void ImageProcess (uint3 id : SV_DispatchThreadID)
{

    float4 color = Result[id.xy];

    float fadeFactor = 0.001;
    
    // blur the color by averaging the color of the neighboring pixels
    float4 sum = float4(0, 0, 0, 0);
    int count = 0;
    int range = 1;
    for (int i = -range; i <= range; i++) // swap this for three cel evaluation using the vel to calculate the direction
    {
        for (int j = -range; j <= range; j++)
        {
            int2 neighborPos = int2(id.xy.x + i, id.xy.y + j);
            if (neighborPos.x >= 0 && neighborPos.x < _width && neighborPos.y >= 0 && neighborPos.y < _height)
            {
                sum += Result[neighborPos];
                count++;
            }
        }
    }
    color = sum / count;

    // Write the faded color back to the result
    Result[id.xy] = color-fadeFactor;
}
